const path = require('path');
const { listServices, readRepoYAML, writeRepoYAML, writeRepoFile } = require('../../utils');

const SERVICES = listServices();

const COMPOSE_FILENAME = 'docker-compose.yml';
const COMPOSE_ENV = '.env';
const ports = {
  rabbitmq: [5672, 15672],
  postgres: [5432],
  taskclusterRoot: [3050],
  ui: [9000],
  'web-server': [3050],
};

const mapServicePorts = (service) => (ports[service] || []).map((port => `${port}:${port}`));

exports.tasks = [];

exports.tasks.push({
  title: `Generate docker-compose.yml`,
  requires: [
    'target-docker-compose-dotenv',
    ...SERVICES.map(name => `configs-${name}`),
    ...SERVICES.map(name => `procslist-${name}`),
  ],
  provides: ['target-docker-compose.yml'],
  run: async (requirements, utils) => {
    const serviceDefinition = (name, overrides = {}) => ({
      image: '${TC_IMAGE}',
      env_file: ['.env'],
      networks: ['local'],
      ...overrides,
      ...((overrides.ports || mapServicePorts(name)).length > 0
        ? { ports: overrides.ports || mapServicePorts(name) } : {}),
    });

    const dockerCompose = {
      version: '3',
      volumes: {
        'db-data': {},
      },
      networks: {
        local: {
          driver: 'bridge',
        },
      },
      services: {
        rabbitmq: serviceDefinition('rabbitmq', {
          image: 'rabbitmq:3.7.8-management',
          healthcheck: {
            test: 'rabbitmq-diagnostics ping',
            interval: '1s',
            timeout: '2s',
            retries: 30,
            start_period: '3s',
          },
        }),
        postgres: serviceDefinition('postgres', {
          image: 'postgres:11',
          volumes: [
            'db-data:/var/lib/postgresql/data',
            './docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql',
          ],
          environment: {
            POSTGRES_HOST_AUTH_METHOD: 'trust',
            LC_COLLATE: 'en_US.UTF8',
            LC_CTYPE: 'en_US.UTF8',
          },
          healthcheck: {
            test: 'pg_isready -U postgres',
            interval: '1s',
            timeout: '2s',
            retries: 30,
            start_period: '3s',
          },
        }),
        pg_init_db: serviceDefinition('pg_init_db', {
          command: ['script/db:upgrade'],
          depends_on: {
            postgres: {
              condition: 'service_healthy',
            },
          },
        }),
        ui: serviceDefinition('ui', { command: ['ui/web'] }),
      },
    };

    for (let name of SERVICES) {
      const procs = requirements[`procslist-${name}`];
      // only web services for now

      Object.keys(procs).forEach((proc) => {
        if (procs[proc].type !== 'web') {
          return;
        }

        dockerCompose.services[`${name}-${proc}`] = serviceDefinition(name, {
          // entrypoint is defined in dockerfile
          // command is defined in entrypoint and is SERVICE/PROC
          command: [`${name}/${proc}`],
          depends_on: {
            rabbitmq: {
              condition: 'service_healthy',
            },
            postgres: {
              condition: 'service_healthy',
            },
          },
        });
      });
    }

    await writeRepoYAML(path.join('.', COMPOSE_FILENAME), dockerCompose);
    return {
      'target-docker-compose.yml': dockerCompose,
    };
  },
}, {
  title: `Generate .env`,
  requires: [
    ...SERVICES.map(name => `configs-${name}`),
    ...SERVICES.map(name => `procslist-${name}`),
  ],
  provides: ['target-docker-compose-dotenv'],
  run: async (requirements, utils) => {
    const currentRelease = await readRepoYAML(path.join('infrastructure', 'tooling', 'current-release.yml'));

    const values = {
      '# Autogenerated, do not edit': '',
      TC_IMAGE: currentRelease.image,
      NODE_ENV: 'development',
      '# DB': '',
      POSTGRES_DB: 'taskcluster',
      USERNAME_PREFIX: 'test',
      ADMIN_DB_URL: `postgresql://postgres@postgres:${ports.postgres[0]}/taskcluster`,
      READ_DB_URL: `postgresql://postgres@postgres:${ports.postgres[0]}/taskcluster`,
      WRITE_DB_URL: `postgresql://postgres@postgres:${ports.postgres[0]}/taskcluster`,

      '# For UI and services': '',
      TASKCLUSTER_ROOT_URL: `http://localhost:${ports.taskclusterRoot[0]}`,

      '# RabbitMQ config': '',
      PULSE_USERNAME: 'admin',
      PULSE_PASSWORD: 'admin',
      PULSE_HOSTNAME: 'rabbitmq',
      PULSE_VHOST: 'local',
      PULSE_AMQPS: 'false',
      RABBITMQ_DEFAULT_USER: 'admin',
      RABBITMQ_DEFAULT_PASS: 'admin',
      RABBITMQ_DEFAULT_VHOST: 'local',
    };

    await writeRepoFile(
      path.join('.', COMPOSE_ENV),
      Object.entries(values).map((pair) => pair.filter((x) => !!x).join('=')).join('\n'),
    );
  },
});
