const path = require('path');
const { listServices, readRepoYAML, writeRepoYAML, writeRepoFile } = require('../../utils');

const SERVICES = listServices();

const ports = {
  rabbitmq: [5672, 15672],
  postgres: [5432],
  taskclusterRoot: [3050],
  ui: [9000],
  'web-server': [3050],
};

const mapServicePorts = (service) => (ports[service] || []).map((port => `${port}:${port}`));

exports.tasks = [];

exports.tasks.push({
  title: `Generate docker-compose.yml`,
  requires: [
    'target-docker-compose-dotenv',
    ...SERVICES.map(name => `configs-${name}`),
    ...SERVICES.map(name => `procslist-${name}`),
  ],
  provides: ['target-docker-compose.yml'],
  run: async (requirements, utils) => {
    const currentRelease = await readRepoYAML(path.join('infrastructure', 'tooling', 'current-release.yml'));

    const serviceDefinition = (name, overrides = {}) => ({
      image: overrides.image || currentRelease.image,
      env_file: overrides.env_file || ['.env'],
      networks: overrides.networks || ['local'],
      ...(overrides.depends_on ? { depends_on: overrides.depends_on } : {}),
      ...((overrides.ports || mapServicePorts(name)).length > 0
        ? { ports: overrides.ports || mapServicePorts(name) } : {}),
      ...(overrides.command ? { command: overrides.command } : {}),
      ...(overrides.environment ? { environment: overrides.environment } : {}),
    });

    const dockerCompose = {
      version: '3',
      volumes: {
        'db-data': {},
      },
      networks: {
        local: {
          driver: 'bridge',
        },
      },
      services: {
        rabbitmq: serviceDefinition('rabbitmq', {
          image: 'rabbitmq:3.7.8-management',
        }),
        postgres: serviceDefinition('postgres', {
          image: 'postgres:11',
          volumes: ['db-data:/var/lib/postgresql/data'],
          environment: {
            POSTGRES_HOST_AUTH_METHOD: 'trust',
            LC_COLLATE: 'en_US.UTF8',
            LC_CTYPE: 'en_US.UTF8',
          },
        }),
        ui: serviceDefinition('ui', { args: ['ui/web'] }),
      },
    };

    for (let name of SERVICES) {
      const procs = requirements[`procslist-${name}`];
      // only web services for now

      Object.keys(procs).forEach((proc) => {
        if (procs[proc].type !== 'web') {
          return;
        }

        dockerCompose.services[`${name}-${proc}`] = serviceDefinition(name, {
          // entrypoint is defined in dockerfile
          // command is defined in entrypoint and is SERVICE/PROC
          command: [`${name}/${proc}`],
          depends_on: ['rabbitmq', 'postgres'],
        });
      });
    }

    await writeRepoYAML(path.join('.', 'docker-compose.yml.sample'), dockerCompose);
    return {
      'target-docker-compose.yml': dockerCompose,
    };
  },
}, {
  title: `Generate .env`,
  requires: [
    ...SERVICES.map(name => `configs-${name}`),
    ...SERVICES.map(name => `procslist-${name}`),
  ],
  provides: ['target-docker-compose-dotenv'],
  run: async (requirements, utils) => {
    const values = {
      '# Autogenerated, do not edit': '',
      NODE_ENV: 'development',
      '# DB': '',
      USERNAME_PREFIX: 'test',
      ADMIN_DB_URL: `postgresql://postgres@postgres:${ports.postgres[0]}/postgres`,
      READ_DB_URL: `postgresql://postgres@postgres:${ports.postgres[0]}/postgres`,
      WRITE_DB_URL: `postgresql://postgres@postgres:${ports.postgres[0]}/postgres`,

      '# For UI and services': '',
      TASKCLUSTER_ROOT_URL: `http://localhost:${ports.taskclusterRoot[0]}`,

      '# RabbitMQ config': '',
      PULSE_USERNAME: 'admin',
      PULSE_PASSWORD: 'admin',
      PULSE_HOSTNAME: 'rabbitmq',
      PULSE_VHOST: 'local',
      PULSE_AMQPS: 'false',
    };

    await writeRepoFile(
      path.join('.', '.env.sample'),
      Object.entries(values).map((pair) => pair.filter((x) => !!x).join('=')).join('\n'),
    );
  },
});
